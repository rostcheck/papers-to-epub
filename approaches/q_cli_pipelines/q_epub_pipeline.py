#!/usr/bin/env python3
import subprocess
import tempfile
import json
from pathlib import Path
from epub_quality_analyzer import EpubQualityAnalyzer
import xml.etree.ElementTree as ET

class QEpubPipeline:
    def __init__(self):
        self.epub_dir = Path("epub_books")
        self.epub_dir.mkdir(exist_ok=True)
    
    def convert_pdf(self, pdf_path):
        """Convert PDF using Q CLI cognitive processing"""
        pdf_path = Path(pdf_path)
        print(f"ðŸ¤– Converting {pdf_path.name} using Q CLI...")
        
        # Create personalized instructions
        instructions = self._create_instructions(pdf_path)
        
        # Invoke Q CLI
        result = self._invoke_q_cli(instructions)
        
        if result['success']:
            # Find the generated ePub
            epub_path = self._find_generated_epub(pdf_path)
            
            if epub_path:
                # Validate the ePub
                validation_result = self._validate_epub(epub_path)
                return {
                    'success': True,
                    'epub_path': epub_path,
                    'validation': validation_result
                }
        
        return {'success': False, 'error': result.get('error', 'Unknown error')}
    
    def _create_instructions(self, pdf_path):
        """Create personalized instructions for the PDF"""
        instructions_template = Path("q_conversion_instructions.md").read_text()
        
        # Customize for this specific PDF
        instructions = instructions_template.replace("{pdf_path}", str(pdf_path))
        
        # Save to temp file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
            f.write(instructions)
            return f.name
    
    def _invoke_q_cli(self, instructions_file):
        """Invoke Q CLI with the instructions"""
        try:
            cmd = [
                "q", "chat", 
                f"Please read the instructions in {instructions_file} and execute them completely. Focus on creating a high-quality ePub with proper structure, tables, and formatting."
            ]
            
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                timeout=300  # 5 minute timeout
            )
            
            # Clean up temp file
            Path(instructions_file).unlink()
            
            if result.returncode == 0:
                return {'success': True, 'output': result.stdout}
            else:
                return {'success': False, 'error': result.stderr}
                
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Q CLI timeout'}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _find_generated_epub(self, pdf_path):
        """Find the ePub file generated by Q CLI"""
        # Look for recently created ePub files
        epub_files = list(self.epub_dir.glob("*.epub"))
        
        if not epub_files:
            return None
        
        # Return the most recently modified ePub
        return max(epub_files, key=lambda p: p.stat().st_mtime)
    
    def _validate_epub(self, epub_path):
        """Comprehensive ePub validation"""
        validation = {
            'xml_valid': False,
            'quality_issues': [],
            'structure_valid': False,
            'file_size': 0
        }
        
        try:
            # Check file size
            validation['file_size'] = epub_path.stat().st_size
            
            # XML validation (smoke test)
            validation['xml_valid'] = self._validate_xml_structure(epub_path)
            
            # Quality analysis
            analyzer = EpubQualityAnalyzer(epub_path)
            issues = analyzer.analyze()
            validation['quality_issues'] = issues
            
            # Structure validation
            validation['structure_valid'] = self._validate_epub_structure(epub_path)
            
        except Exception as e:
            validation['error'] = str(e)
        
        return validation
    
    def _validate_xml_structure(self, epub_path):
        """Validate XML structure for parsing errors"""
        try:
            import zipfile
            with zipfile.ZipFile(epub_path, 'r') as epub:
                # Check main content files
                for filename in ['content.html', 'content.opf', 'toc.ncx']:
                    try:
                        content = epub.read(filename).decode('utf-8')
                        # Try to parse as XML
                        if filename.endswith('.html'):
                            # Basic HTML validation
                            if '&' in content and '&amp;' not in content.replace('&amp;', ''):
                                return False  # Unescaped ampersands
                        else:
                            # XML validation
                            ET.fromstring(content)
                    except:
                        return False
            return True
        except:
            return False
    
    def _validate_epub_structure(self, epub_path):
        """Validate ePub has required structure"""
        try:
            import zipfile
            with zipfile.ZipFile(epub_path, 'r') as epub:
                files = epub.namelist()
                
                # Check required files
                required = ['mimetype', 'META-INF/container.xml', 'content.opf']
                return all(f in files for f in required)
        except:
            return False

def main():
    """Test the Q CLI pipeline"""
    pipeline = QEpubPipeline()
    
    # Test with a PDF
    test_pdf = "./Sakana.ai/2502.14297v2.pdf"
    
    if Path(test_pdf).exists():
        result = pipeline.convert_pdf(test_pdf)
        
        print("\n=== Q CLI Pipeline Results ===")
        print(f"Success: {result['success']}")
        
        if result['success']:
            print(f"ePub created: {result['epub_path']}")
            validation = result['validation']
            print(f"XML valid: {validation['xml_valid']}")
            print(f"Structure valid: {validation['structure_valid']}")
            print(f"Quality issues: {len(validation['quality_issues'])}")
            print(f"File size: {validation['file_size']} bytes")
        else:
            print(f"Error: {result['error']}")
    else:
        print("Test PDF not found")

if __name__ == "__main__":
    main()
